#!/bin/bash

# Check if user input is provided
if [ -z "$*" ]; then
    echo "Requires a prompt of what you want to download, i.e."
    echo '"llytdlp download this YouTube video https://www.youtube.com/watch?v=..."'
    exit 1
fi

# Capture command-line arguments and escape for JSON
user_input="$*"

# Escape special characters for JSON
# Replace backslash first, then other special characters
user_input_escaped=$(echo "$user_input" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/\t/\\t/g' | sed 's/\r/\\r/g' | sed 's/\n/\\n/g')

# Conditional check for API keys
if [ -n "$DEEPSEEK_API_KEY" ]; then
    # Store the curl response as a variable for Deepseek API
    response=$(curl -s "https://api.deepseek.com/v1/chat/completions" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $DEEPSEEK_API_KEY" \
        -d "{
            \"model\": \"deepseek-chat\",
            \"messages\": [
                {
                    \"role\": \"system\",
                    \"content\": \"You are a yt-dlp command generator. Based on the user's description, generate only the appropriate yt-dlp command line without any additional explanation. Use sensible output file names based on video title or as specified by user. For single videos, use current directory as output location. For playlists, create a subdirectory with playlist name. For audio extraction, include appropriate audio options. For subtitles, include subtitle download options when requested. Use safe defaults: --ignore-errors --no-overwrites. Always specify output template with meaningful names. Use best quality by default unless user specifies otherwise. Answer with a single line command without explanations or markdown formatting. Only output the command itself.\"
                },
                {
                    \"role\": \"user\",
                    \"content\": \"$user_input_escaped\"
                }
            ],
            \"temperature\": 0.3,
            \"max_tokens\": 1024,
            \"top_p\": 1,
            \"stream\": false
        }")
elif [ -n "$KIMI_API_KEY" ]; then
    # Store the curl response as a variable for Kimi API (Moonshot AI)
    response=$(curl -s "https://api.moonshot.cn/v1/chat/completions" \
        -X POST \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer ${KIMI_API_KEY}" \
        -d "{
            \"model\": \"kimi-k2-0711-preview\",
            \"messages\": [
                {
                    \"role\": \"system\",
                    \"content\": \"You are a yt-dlp command generator. Based on the user's description, generate only the appropriate yt-dlp command line without any additional explanation. Use sensible output file names based on video title or as specified by user. For single videos, use current directory as output location. For playlists, create a subdirectory with playlist name. For audio extraction, include appropriate audio options. For subtitles, include subtitle download options when requested. Use safe defaults: --ignore-errors --no-overwrites. Always specify output template with meaningful names. Use best quality by default unless user specifies otherwise. Answer with a single line command without explanations or markdown formatting. Only output the command itself.\"
                },
                {
                    \"role\": \"user\",
                    \"content\": \"$user_input_escaped\"
                }
            ],
            \"temperature\": 0.3,
            \"max_tokens\": 1024,
            \"top_p\": 1,
            \"stream\": false
        }")
else
    echo "No API key found. Please set DEEPSEEK_API_KEY or KIMI_API_KEY."
    exit 1
fi

# Debug: Show raw response (comment out in production)
echo "Debug - API Response:"
echo "$response"
echo "---"

# Check if response is empty
if [ -z "$response" ]; then
    echo "Error: API returned empty response."
    exit 1
fi

# Check for API error
if echo "$response" | grep -q '"error"'; then
    echo "Error: API returned an error:"
    echo "$response" | grep -o '"message":"[^"]*"' | sed 's/"message":"//;s/"$//'
    exit 1
fi

# Try multiple methods to extract content
# Method 1: Using Python (most reliable)
if command -v python3 &> /dev/null; then
    command=$(echo "$response" | python3 -c "
import sys
import json
try:
    data = json.load(sys.stdin)
    content = data.get('choices', [{}])[0].get('message', {}).get('content', '')
    print(content.strip())
except:
    pass
")
fi

# Method 2: Using jq if available
if [ -z "$command" ] && command -v jq &> /dev/null; then
    command=$(echo "$response" | jq -r '.choices[0].message.content' 2>/dev/null)
fi

# Method 3: Improved grep/sed method
if [ -z "$command" ] || [ "$command" = "null" ]; then
    # Extract everything between "content":" and the next "
    command=$(echo "$response" | sed -n 's/.*"content"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -1)
    # Handle escaped characters
    command=$(echo "$command" | sed 's/\\n/\n/g; s/\\t/\t/g; s/\\"/"/g; s/\\\\/\\/g')
fi

# Clean up the command (remove markdown code blocks if present)
command=$(echo "$command" | sed 's/^```.*$//g; s/^`//g; s/`$//g' | grep -v '^$' | head -1)

# Check if command extraction was successful
if [ -z "$command" ] || [ "$command" = "null" ]; then
    echo "Error: Failed to extract command from API response."
    echo "Raw response was:"
    echo "$response"
    exit 1
fi

# Echo the command
echo ""
echo "Generated command: $command"
echo ""

# Prompt the user to run the command
read -p "Press Enter to run the command, or Ctrl+C to cancel..."

# Run the command
eval "$command"
